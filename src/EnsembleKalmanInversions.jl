module EnsembleKalmanInversions

export
    iterate!,
    EnsembleKalmanInversion,
    Resampler,
    FullEnsembleDistribution,
    SuccessfulEnsembleDistribution

using OffsetArrays
using ProgressBars
using Random
using Printf
using LinearAlgebra
using Statistics
using Distributions
using EnsembleKalmanProcesses:
    get_u_final,
    Inversion,
    Sampler,
    update_ensemble!,
    EnsembleKalmanProcess

using ..Parameters: unconstrained_prior, transform_to_constrained, inverse_covariance_transform
using ..InverseProblems: Nensemble, observation_map, forward_map, tupify_parameters
using ..InverseProblems: inverting_forward_map

using Oceananigans.Utils: prettytime

mutable struct EnsembleKalmanInversion{E, I, M, O, S, R, X, G, C}
    inverse_problem :: I
    ensemble_kalman_process :: E
    mapped_observations :: M
    noise_covariance :: O
    iteration :: Int
    iteration_summaries :: S
    resampler :: R
    unconstrained_parameters :: X
    forward_map_output :: G
    convergence_rate :: C
end

Base.show(io::IO, eki::EnsembleKalmanInversion) =
    print(io, "EnsembleKalmanInversion", '\n',
              "‚îú‚îÄ‚îÄ inverse_problem: ", summary(eki.inverse_problem), '\n',
              "‚îú‚îÄ‚îÄ ensemble_kalman_process: ", summary(eki.ensemble_kalman_process), '\n',
              "‚îú‚îÄ‚îÄ mapped_observations: ", summary(eki.mapped_observations), '\n',
              "‚îú‚îÄ‚îÄ noise_covariance: ", summary(eki.noise_covariance), '\n',
              "‚îú‚îÄ‚îÄ convergence_rate: $(eki.convergence_rate)", '\n',
              "‚îú‚îÄ‚îÄ iteration: $(eki.iteration)", '\n',
              "‚îú‚îÄ‚îÄ resampler: $(summary(eki.resampler))",
              "‚îú‚îÄ‚îÄ unconstrained_parameters: $(summary(eki.unconstrained_parameters))", '\n',
              "‚îî‚îÄ‚îÄ forward_map_output: $(summary(eki.forward_map_output))")

construct_noise_covariance(noise_covariance::AbstractMatrix, y) = noise_covariance

function construct_noise_covariance(noise_covariance::Number, y)
    Œ∑ = convert(eltype(y), noise_covariance)
    Nobs = length(y)
    return Matrix(Œ∑ * I, Nobs, Nobs)
end

"""
    EnsembleKalmanInversion(inverse_problem;
                            noise_covariance = 1,
                            convergence_rate = 0.7,
                            resampler = Resampler(),
                            unconstrained_parameters = nothing,
                            forward_map_output = nothing,
                            process = Inversion())

Return an object that finds local minima of the inverse problem:

```math
y = G(Œ∏) + Œ∑,
```

for the parameters ``Œ∏``, where ``y`` is a vector of observations (often normalized),
``G(Œ∏)`` is a forward map that predicts the observations, and ``Œ∑ ‚àº ùí©(0, Œì_y)`` is zero-mean
random noise with a `noise_covariance` matrix ``Œì_y`` representing uncertainty in the observations.

The "forward map output" `G` is model output mapped to the space of `inverse_problem.observations`.

(For more details on the Ensemble Kalman Inversion algorithm refer to the
[EnsembleKalmanProcesses.jl Documentation](https://clima.github.io/EnsembleKalmanProcesses.jl/stable/ensemble_kalman_inversion/).)

Arguments
=========

- `inverse_problem` (`InverseProblem`): Represents an inverse problem representing the comparison between
                                        synthetic observations generated by
                                        [Oceananigans.jl](https://clima.github.io/OceananigansDocumentation/stable/)
                                        and model predictions, also generated by Oceananigans.jl.

- `noise_covariance` (`Number` or `AbstractMatrix`): Covariance matrix representing observational uncertainty.
                                                     `noise_covariance::Number` is converted to a scaled identity matrix.

- `convergence_rate` (`Number`): The convergence rate for the EKI adaptive time stepping. Default value 0.7.
                                 If provided with `nothing` the EKI iterations are done with a fixed "time step".
                                 If a numerical value is given is 0.7 which implies that the parameter spread 
                                 covariance is decreased to 70% of the parameter spread covariance at the previous
                                 EKI iteration.

- `resampler`: controls particle resampling procedure. See `Resampler`.

- `process`: The Ensemble Kalman process. Default: `Inversion().
"""
function EnsembleKalmanInversion(inverse_problem;
                                 noise_covariance = 1,
                                 convergence_rate = 0.7,
                                 resampler = Resampler(),
                                 unconstrained_parameters = nothing,
                                 forward_map_output = nothing,
                                 process = Inversion())

    if process isa Sampler && !isnothing(convergence_rate)
        @warn "Process is $process; ignoring keyword argument convergence_rate=$convergence_rate."
        convergence_rate = nothing
    end

    if isnothing(unconstrained_parameters)
        isnothing(forward_map_output) ||
            throw(ArgumentError("Cannot provide forward_map_output without unconstrained_parameters."))

        free_parameters = inverse_problem.free_parameters
        priors = free_parameters.priors
        NŒ∏ = length(priors)
        Nens = Nensemble(inverse_problem)

        # Generate an initial sample of parameters
        unconstrained_priors = NamedTuple(name => unconstrained_prior(priors[name])
                                          for name in free_parameters.names)

        unconstrained_parameters = [rand(unconstrained_priors[i]) for i=1:NŒ∏, k=1:Nens]
    end

    # Build EKP-friendly observations "y" and the covariance matrix of observational uncertainty "Œìy"
    y = dropdims(observation_map(inverse_problem), dims=2) # length(forward_map_output) column vector
    Œìy = construct_noise_covariance(noise_covariance, y) # noise_covariance * UniformScaling(1.0)
    X·µ¢ = unconstrained_parameters
    iteration = 0

    eki‚Ä≤ = EnsembleKalmanInversion(inverse_problem,
                                   process,
                                   y,
                                   Œìy,
                                   iteration,
                                   nothing,
                                   resampler,
                                   X·µ¢,
                                   forward_map_output,
                                   convergence_rate)

    if isnothing(forward_map_output) # execute forward map to generate initial summary and forward_map_output
        @info "Executing forward map while building EnsembleKalmanInversion..."
        start_time = time_ns()
        forward_map_output = resampling_forward_map!(eki‚Ä≤, X·µ¢)
        elapsed_time = (time_ns() - start_time) * 1e-9
        @info "    ... done ($(prettytime(elapsed_time)))."
    end

    summary = IterationSummary(eki‚Ä≤, X·µ¢, forward_map_output)
    iteration_summaries = OffsetArray([summary], -1)

    eki = EnsembleKalmanInversion(inverse_problem,
                                  eki‚Ä≤.ensemble_kalman_process,
                                  eki‚Ä≤.mapped_observations,
                                  eki‚Ä≤.noise_covariance,
                                  iteration,
                                  iteration_summaries,
                                  eki‚Ä≤.resampler,
                                  eki‚Ä≤.unconstrained_parameters,
                                  forward_map_output,
                                  eki‚Ä≤.convergence_rate)

    return eki
end

include("iteration_summary.jl")
include("resampling.jl")

#####
##### Iterating
#####

function resampling_forward_map!(eki, X=eki.unconstrained_parameters)
    G = inverting_forward_map(eki.inverse_problem, X) # (len(G), Nensemble)
    resample!(eki.resampler, X, G, eki)
    return G
end

"""
    iterate!(eki::EnsembleKalmanInversion;
             iterations = 1,
             convergence_rate = eki.convergence_rate,
             show_progress = true)

Iterate the ensemble Kalman inversion problem `eki` forward by `iterations`.

Return
======

- `best_parameters`: the ensemble mean of all parameter values after the last iteration.
"""
function iterate!(eki::EnsembleKalmanInversion;
                  iterations = 1,
                  convergence_rate = eki.convergence_rate,
                  show_progress = true)

    iterator = show_progress ? ProgressBar(1:iterations) : 1:iterations

    for _ in iterator
        eki.unconstrained_parameters = step_parameters(eki, convergence_rate)
        eki.iteration += 1

        # Forward map
        eki.forward_map_output = resampling_forward_map!(eki)
        summary = IterationSummary(eki, eki.unconstrained_parameters, eki.forward_map_output)
        push!(eki.iteration_summaries, summary)
    end

    # Return ensemble mean (best guess for optimal parameters)
    best_parameters = eki.iteration_summaries[end].ensemble_mean

    return best_parameters
end

#####
##### Stepping and adaptive stepping
#####

function step_parameters(X, G, y, Œìy, process; step_size=1.0)
    ekp = EnsembleKalmanProcess(X, y, Œìy, process; Œît=step_size)
    update_ensemble!(ekp, G)
    return get_u_final(ekp)
end

# it's not adaptive
adaptive_step_parameters(::Nothing, X‚Åø, G‚Åø, y, Œìy, process) = step_parameters(X, G, y, Œìy, process)

function step_parameters(eki::EnsembleKalmanInversion, convergence_rate)
    process = eki.ensemble_kalman_process
    y = eki.mapped_observations
    Œìy = eki.noise_covariance
    G‚Åø = eki.forward_map_output
    X‚Åø = eki.unconstrained_parameters
    X‚Åø‚Å∫¬π = similar(X‚Åø)

    # Handle failed particles
    nan_values = column_has_nan(G‚Åø)
    failed_columns = findall(nan_values) # indices of columns (particles) with `NaN`s
    successful_columns = findall(.!nan_values)
    some_failures = length(failed_columns) > 0

    some_failures && @warn string(length(failed_columns), " particles failed. ",
                                  "Performing ensemble update with statistics from ",
                                  length(successful_columns), " successful particles.")

    successful_G‚Åø = G‚Åø[:, successful_columns]
    successful_X‚Åø = X‚Åø[:, successful_columns]
    
    # Construct new parameters
    successful_X‚Åø‚Å∫¬π = adaptive_step_parameters(convergence_rate, successful_X‚Åø, successful_G‚Åø, y, Œìy, process)
    X‚Åø‚Å∫¬π[:, successful_columns] .= successful_X‚Åø‚Å∫¬π

    if some_failures # resample failed particles with new ensemble distribution
        new_X_distribution = ensemble_normal_distribution(successful_X‚Åø‚Å∫¬π) 
        sampled_X‚Åø‚Å∫¬π = rand(new_X_distribution, length(failed_columns))
        X‚Åø‚Å∫¬π[:, failed_columns] .= sampled_X‚Åø‚Å∫¬π
    end

    return X‚Åø‚Å∫¬π
end

#####
##### Adaptive parameter stepping
#####

function volume_ratio(X‚Åø‚Å∫¬π, X‚Åø)
    V‚Åø‚Å∫¬π = det(cov(X‚Åø‚Å∫¬π, dims=2))
    V‚Åø   = det(cov(X‚Åø,   dims=2))
    return V‚Åø‚Å∫¬π / V‚Åø
end

function adaptive_step_parameters(convergence_rate, X‚Åø, G‚Åø, y, Œìy, process)
    # Test step forward
    step_size = 1
    X‚Åø‚Å∫¬π = step_parameters(X‚Åø, G‚Åø, y, Œìy, process; step_size)
    r = volume_ratio(X‚Åø‚Å∫¬π, X‚Åø)

    # "Accelerated" fixed point iteration to adjust step_size
    p = 1.1
    iter = 1
    while !isapprox(r, convergence_rate, atol=0.03, rtol=0.1) && iter < 10
        step_size *= (r / convergence_rate)^p
        X‚Åø‚Å∫¬π = step_parameters(X‚Åø, G‚Åø, y, Œìy, process; step_size)
        r = volume_ratio(X‚Åø‚Å∫¬π, X‚Åø)
        iter += 1
    end

    @info "Particles stepped adaptively with convergence rate $r (target $convergence_rate)"

    return X‚Åø‚Å∫¬π
end

end # module
